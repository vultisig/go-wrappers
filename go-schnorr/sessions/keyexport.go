// Provides Go bindings for interacting with the Rust library
// that implements the Key Export Session functionality
// within the Schnorr protocol.
//
// This file includes functions for managing key export functionality.
// It is facilitating seamless communication between Go and Rust.
//
// Key functionalities include:
// - Creating and managing key export sessions
// - Handling of input messages from a key exporter
// - Finalization the key export session.
// - Decoding of setup messages and encrypting of the private key shares
// - Handling communication between Go and Rust for efficient resource utilization
package session

/*
#include "../../includes/go-schnorr.h"
#include <stdlib.h>
*/
import "C"
import (
	"go-wrapper/go-schnorr/errors"
	"runtime"
	"strings"
	"unsafe"
)

// SchnorrKeyExportReceiverNew creates a key export receiver session and generate setup message for
// key exporters.
//
// Parameters:
//   - share: Handle - key share handle.
//   - ids: []string - human readable party identifiers.
//
// Returns:
//   - Handle: handle which will store the allocated session.
//   - []byte: a byte slice containing the setup message.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func SchnorrKeyExportReceiverNew(share Handle, ids []string) (Handle, []byte, error) {
	pinner := new(runtime.Pinner)
	defer pinner.Unpin()

	cShare := cHandle(share)

	idsBytes := []byte(strings.Join(ids, "\x00"))
	cIDs := (*C.go_slice)(unsafe.Pointer(&idsBytes))
	pinner.Pin(&idsBytes[0])

	cSetupMsg := C.tss_buffer{}
	defer C.tss_buffer_free(&cSetupMsg)

	cHnd := C.Handle{}

	res := C.schnorr_key_export_receiver_new(
		cShare,
		cIDs,
		&cSetupMsg,
		&cHnd,
	)
	if res != 0 {
		return 0, nil, errors.MapLibError(int(res))
	}

	setup := C.GoBytes(unsafe.Pointer(cSetupMsg.ptr), C.int(cSetupMsg.len))

	return Handle(cHnd._0), setup, nil
}

// SchnorrKeyExportReceiverInputMessage handles input message from a key exporter.
//
// Parameters:
//   - session: Handle - key export receiver session handle.
//   - message: []byte - an input message.
//
// Returns:
//   - bool:  will be set to true if the input message is last for the session.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func SchnorrKeyExportReceiverInputMessage(session Handle, message []byte) (bool, error) {
	pinner := new(runtime.Pinner)
	defer pinner.Unpin()

	cSession := cHandle(session)
	cMessage := cGoSlice(message, pinner)

	finished := C.int32_t(0)

	res := C.schnorr_key_export_receiver_input_message(
		cSession,
		cMessage,
		&finished,
	)
	if res != 0 {
		return false, errors.MapLibError(int(res))
	}

	return finished != 0, nil
}

// SchnorrKeyExportReceiverFinish finishes the key export receiver session.
//
// Parameters:
//   - session: Handle - key export receiver session handle
//
// Returns:
//   - []byte:  an exported private key.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func SchnorrKeyExportReceiverFinish(session Handle) ([]byte, error) {
	cSession := cHandle(session)

	cSecret := C.tss_buffer{}
	defer C.tss_buffer_free(&cSecret)

	res := C.schnorr_key_export_receiver_finish(
		cSession,
		&cSecret,
	)
	if res != 0 {
		return nil, errors.MapLibError(int(res))
	}

	secret := C.GoBytes(unsafe.Pointer(cSecret.ptr), C.int(cSecret.len))

	return secret, nil
}

// SchnorrKeyExporter decodes the setup message and encrypts the share of private key for
// the key export receiver session
//
// Parameters:
//   - share: Handle - key share handle.
//   - id: string - a human readable identifier
//   - setupMsg: []byte - setup message generated by SchnorrKeyExportReceiverNew()
//
// Returns:
//   - []byte: encrypted message.
//   - string: key export receiver
//   - error: an error if the Rust function call fails or if any other issue occurs.
func SchnorrKeyExporter(share Handle, id string, setupMsg []byte) ([]byte, string, error) {
	pinner := new(runtime.Pinner)
	defer pinner.Unpin()

	cShare := cHandle(share)
	cSetup := cGoSlice(setupMsg, pinner)

	idBytes := []byte(id)
	cID := (*C.go_slice)(unsafe.Pointer(&idBytes))
	pinner.Pin(&idBytes[0])

	cMessage := C.tss_buffer{}
	defer C.tss_buffer_free(&cMessage)

	cReceiver := C.tss_buffer{}
	defer C.tss_buffer_free(&cReceiver)

	res := C.schnorr_key_exporter(
		cShare,
		cID,
		cSetup,
		&cMessage,
		&cReceiver,
	)

	if res != 0 {
		return nil, "", errors.MapLibError(int(res))
	}

	message := C.GoBytes(unsafe.Pointer(cMessage.ptr), C.int(cMessage.len))
	receiver := string(C.GoBytes(unsafe.Pointer(cReceiver.ptr), C.int(cReceiver.len)))

	return message, receiver, nil
}
