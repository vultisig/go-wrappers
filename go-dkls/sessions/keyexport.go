// Provides Go bindings for interacting with the Rust library
// that implements the Key Export Session functionality
// within the DKLS protocol.
//
// This file includes functions for managing key export functionality.
// It is facilitating seamless communication between Go and Rust.
//
// Key functionalities include:
// - Creating and managing key export sessions
// - Handling of input messages from a key exporter
// - Finalization the key export session.
// - Decoding of setup messages and encrypting of the private key shares
// - Handling communication between Go and Rust for efficient resource utilization
package session

/*
#include "../../includes/go-dkls.h"
#include <stdlib.h>
*/
import "C"
import (
	"go-wrapper/go-dkls/errors"
	"runtime"
	"strings"
	"unsafe"
)

// DklsKeyExportReceiverNew creates a key export receiver session and generate setup message for
// key exporters.
//
// Parameters:
//   - share: Handle - key share handle.
//   - ids: []string - human readable party identifiers.
//
// Returns:
//   - Handle: handle which will store the allocated session.
//   - []byte: a byte slice containing the setup message.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func DklsKeyExportReceiverNew(share Handle, ids []string) (Handle, []byte, error) {
	pinner := runtime.Pinner{}
	defer pinner.Unpin()

	idsBytes := []byte(strings.Join(ids, "\x00"))
	cIds := (*C.go_slice)(unsafe.Pointer(&idsBytes))
	pinner.Pin(&idsBytes[0])

	setupMsg := C.tss_buffer{}
	defer C.tss_buffer_free(&setupMsg)

	handle := C.Handle{}

	rc := C.dkls_key_export_receiver_new(
		cHandle(share),
		cIds,
		&setupMsg,
		&handle,
	)

	if rc != 0 {
		return 0, nil, errors.MapLibError(int(rc))
	}

	setup := C.GoBytes(unsafe.Pointer(setupMsg.ptr), C.int(setupMsg.len))

	return Handle(handle._0), setup, nil
}

// DklsKeyExportReceiverInputMessage handles input message from a key exporter.
//
// Parameters:
//   - session: Handle - key export receiver session handle.
//   - message: []byte - an input message.
//
// Returns:
//   - bool:  will be set to true if the input message is last for the session.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func DklsKeyExportReceiverInputMessage(session Handle, message []byte) (bool, error) {
	pinner := runtime.Pinner{}
	defer pinner.Unpin()

	cMessage := (*C.go_slice)(unsafe.Pointer(&message))
	pinner.Pin(&message[0])

	finished := C.int32_t(0)

	rc := C.dkls_key_export_receiver_input_message(
		C.Handle{_0: C.int32_t(session)},
		cMessage,
		&finished,
	)

	if rc != 0 {
		return false, errors.MapLibError(int(rc))
	}

	return finished != 0, nil
}

// DklsKeyExportReceiverFinish finishes the key export receiver session.
//
// Parameters:
//   - session: Handle - key export receiver session handle.
//
// Returns:
//   - []byte: an exported private key.
//   - error: an error if the Rust function call fails or if any other issue occurs.
func DklsKeyExportReceiverFinish(session Handle) ([]byte, error) {
	cSecret := C.tss_buffer{}
	defer C.tss_buffer_free(&cSecret)

	rc := C.dkls_key_export_receiver_finish(
		cHandle(session),
		&cSecret,
	)

	if rc != 0 {
		return nil, errors.MapLibError(int(rc))
	}

	secret := C.GoBytes(unsafe.Pointer(cSecret.ptr), C.int(cSecret.len))

	return secret, nil
}

// DklsKeyExporter decodes the setup message and encrypts the share of private key for
// the key export receiver session
//
// Parameters:
//   - share: Handle - key share handle.
//   - id: string - a human readable identifier
//   - setupMsg: []byte - setup message generated by DklsKeyExportReceiverNew()
//
// Returns:
//   - []byte: encrypted message.
//   - string: key export receiver
//   - error: an error if the Rust function call fails or if any other issue occurs.
func DklsKeyExporter(share Handle, id string, setupMsg []byte) ([]byte, string, error) {
	pinner := runtime.Pinner{}
	defer pinner.Unpin()

	idBytes := []byte(id)
	cID := (*C.go_slice)(unsafe.Pointer(&idBytes))
	pinner.Pin(&idBytes[0])

	cSetupMsg := (*C.go_slice)(unsafe.Pointer(&setupMsg))
	pinner.Pin(&setupMsg[0])

	cMessage := C.tss_buffer{}
	defer C.tss_buffer_free(&cMessage)

	cReceiver := C.tss_buffer{}
	defer C.tss_buffer_free(&cReceiver)

	rc := C.dkls_key_exporter(
		C.Handle{_0: C.int32_t(share)},
		cID,
		cSetupMsg,
		&cMessage,
		&cReceiver,
	)

	if rc != 0 {
		return nil, "", errors.MapLibError(int(rc))
	}

	message := C.GoBytes(unsafe.Pointer(cMessage.ptr), C.int(cMessage.len))
	receiver := string(C.GoBytes(unsafe.Pointer(cReceiver.ptr), C.int(cReceiver.len)))

	return message, receiver, nil
}
